#!/bin/bash
#$ -S /bin/bash

export VERILATOR_ROOT=$(dirname $(dirname {{ verilator }}))
export SYSTEMC={{ systemc }}
export LD_LIBRARY_PATH=$SYSTEMC/lib-linux{{ ptr_size }}:$LD_LIBRARY_PATH

# Generate native code for the software part.
llc={{ llc }}
{{ llc }} -march={{ llc_march}} \
          {{ [test_binary_root, hardware_function + "_soft.ll"]|joinpath }} \
          -filetype=obj \
          -mc-relax-all \
          -o {{ [bybrid_sim_root, hardware_function + "_soft.o"]|joinpath }} \
|| exit 1

# Generate cpp files from the rtl
{{ verilator }} {{ [test_binary_root, hardware_function + ".sv"]|joinpath }} \
                -Wall --sc -D__DEBUG_IF +define+__VERILATOR_SIM \
                --top-module {{ [hardware_function, "_RTL_DUT"]|join }} \
|| exit 1

# Compile the verilator objects
make -C "{{ bybrid_sim_root }}/obj_dir/"\
      -j -f "V{{ [hardware_function, "_RTL_DUT"]|join }}.mk" \
     "V{{ [hardware_function, "_RTL_DUT"]|join }}__ALL.a" \
|| exit 1

make -C "{{ bybrid_sim_root }}/obj_dir/" \
     -j -f "V{{ [hardware_function, "_RTL_DUT"]|join }}.mk" \
     {{ [test_binary_root, hardware_function + "_if.o"]|joinpath }} "verilated.o" \
|| exit 1

# Generate the testbench executables.
g++ -L$SYSTEMC/lib-linux{{ ptr_size }}  -lsystemc \
    {{ [test_binary_root, hardware_function + "_if.o"]|joinpath }} \
    {{ [bybrid_sim_root, hardware_function + "_soft.o"]|joinpath }} \
    {{ [bybrid_sim_root, "obj_dir", 'V' + hardware_function + "_RTL_DUT__ALL*.o"]|joinpath }} \
    {{ [bybrid_sim_root, "obj_dir", "verilated.o"]|joinpath }} \
    -o {{ [test_binary_root, hardware_function + "_systemc_testbench"]|joinpath }} \
|| exit 1

# Run the systemc testbench
timeout 1200s {{ [test_binary_root, hardware_function + "_systemc_testbench"]|joinpath }} > hardware.out \
|| exit 1

# Compare the hardware output with the standar output
{{ lli }} {{ test_file }} > expected.output || exit 1

[ -f hardware.output ]  && exit 1
diff expected.output hardware.out &&  echo 'correct!' || echo 'Incorrect!'
