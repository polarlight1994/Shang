//===- DesignMetrics.cpp - Estimate the metrics of the design ---*- C++ -*-===//
//
//                      The Shang HLS frameowrk                               //
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implement the DesignMetrics class, which estimate the resource
// usage and speed performance of the design at early stage.
//
//===----------------------------------------------------------------------===//

#include "IR2Datapath.h"
#include "vtm/Passes.h"
#include "vtm/DesignMetrics.h"

#include "llvm/Pass.h"
#include "llvm/Target/TargetData.h"
#include "llvm/Support/InstIterator.h"
#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/Support/CFG.h"
#define DEBUG_TYPE "vtm-design-metrics"
#include "llvm/Support/Debug.h"

using namespace llvm;

namespace llvm {
// Wrapper for the external values.
class VASTValueOperand : public VASTValue {
public:
  const Value *const V;

  VASTValueOperand(const Value *V, unsigned Size)
    : VASTValue(VASTNode::vastCustomNode, Size),
      V(V) {}

  /// Methods for support type inquiry through isa, cast, and dyn_cast:
  static inline bool classof(const VASTValueOperand *A) { return true; }
  static inline bool classof(const VASTNode *A) {
    return A->getASTType() == vastCustomNode;
  }

  void printAsOperandImpl(raw_ostream &OS, unsigned UB, unsigned LB) const {
    OS << *V << '[' << UB << ',' << LB << ']';
  }
};

// FIXME: Move the class definition to a header file.
class DesignMetricsImpl : public EarlyDatapathBuilderContext {
  // Data-path container to hold the optimized data-path of the design.
  DatapathContainer DPContainer;
  EarlyDatapathBuilder Builder;

  // The data-path value which are used by control-path operations.
  typedef std::set<VASTValue*> ValSetTy;
  ValSetTy LiveOutedVal;

  ValSetTy AddressBusFanins, DataBusFanins;
  // The lower bound of the total control-steps.
  unsigned StepLB;
  unsigned NumCalls;
  // TODO: Model the control-path, in the control-path, we can focus on the MUX
  // in the control-path, note that the effect of FU allocation&binding
  // algorithm should also be considered when estimating resource usage.

  // TODO: To not perform cycle-accurate speed performance estimation at the IR
  // layer, instead we should only care about the number of memory accesses.

  using VASTExprBuilderContext::getOrCreateImmediate;

  VASTImmediate *getOrCreateImmediate(const APInt &Value) {
    return DPContainer.getOrCreateImmediateImpl(Value);
  }

  VASTValPtr createExpr(VASTExpr::Opcode Opc, ArrayRef<VASTValPtr> Ops,
                        unsigned UB, unsigned LB) {
    return DPContainer.createExprImpl(Opc, Ops, UB, LB);;
  }

  VASTValPtr getAsOperandImpl(Value *Op, bool GetAsInlineOperand);

  // Visit the expression tree whose root is Root and return the cost of the
  // tree, insert all visited data-path nodes into Visited.
  uint64_t getExprTreeFUCost(VASTValPtr Root, ValSetTy &Visited) const;
  uint64_t getFUCost(VASTValue *V) const;

  // Collect the fanin information of the memory bus.
  void visitLoadInst(LoadInst &I);
  void visitStoreInst(StoreInst &I);
public:
  explicit DesignMetricsImpl(TargetData *TD)
    : Builder(*this, TD), StepLB(0), NumCalls(0){}

  void visit(Instruction &Inst);
  void visit(BasicBlock &BB);
  void visit(Function &F);

  void reset() {
    DPContainer.reset();
    LiveOutedVal.clear();
    AddressBusFanins.clear();
    DataBusFanins.clear();
    StepLB = 0;
    NumCalls = 0;
  }

  // Visit all data-path expression and compute the cost.
  uint64_t getDatapathFUCost() const;
  unsigned getNumAddrBusFanin() const { return AddressBusFanins.size(); }
  unsigned getNumDataBusFanin() const { return DataBusFanins.size(); }
  unsigned getStepsLowerBound() const { return StepLB; }
  unsigned getNumCalls() const { return NumCalls; }

  TargetData *getTargetData() const { return Builder.getTargetData(); }
};

struct DesignMetricsPass : public FunctionPass {
  static char ID;

  DesignMetricsPass() : FunctionPass(ID) {}

  void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.addRequired<TargetData>();
    AU.setPreservesAll();
  }

  bool runOnFunction(Function &F);
};
}

VASTValPtr DesignMetricsImpl::getAsOperandImpl(Value *Op,
                                               bool GetAsInlineOperand) {
  unsigned NumBits = Builder.getValueSizeInBits(Op);

  // Do not mess up with the big Value generated by ScalarRelAggregates pass.
  if (NumBits > 64) return VASTValPtr();

  if (ConstantInt *Int = dyn_cast<ConstantInt>(Op))
    return getOrCreateImmediate(Int->getZExtValue(), NumBits);

  if (VASTValPtr V = Builder.lookupExpr(Op)) {
    // Try to inline the operand if user ask to.
    if (GetAsInlineOperand) V = V.getAsInlineOperand();
    return V;
  }

  // Else we need to create a leaf node for the expression tree.
  VASTValueOperand *ValueOp
    = DPContainer.getAllocator()->Allocate<VASTValueOperand>();
    
  new (ValueOp) VASTValueOperand(Op, NumBits);

  // Remember the newly create VASTValueOperand, so that it will not be created
  // again.
  Builder.indexVASTExpr(Op, ValueOp);
  return ValueOp;
}

void DesignMetricsImpl::visitLoadInst(LoadInst &I) {
  Value *Address = I.getPointerOperand();
  if (VASTValPtr V = getAsOperandImpl(Address, true))
    AddressBusFanins.insert(V.get());
}

void DesignMetricsImpl::visitStoreInst(StoreInst &I) {
  Value *Address = I.getPointerOperand();
  if (VASTValPtr V = getAsOperandImpl(Address, true))
    AddressBusFanins.insert(V.get());

  Value *Data = I.getValueOperand();
  if (VASTValPtr V = getAsOperandImpl(Data, true))
    DataBusFanins.insert(V.get());
}

void DesignMetricsImpl::visit(Instruction &Inst) {
  if (VASTValPtr V = Builder.visit(Inst)) {
    Builder.indexVASTExpr(&Inst, V);
    return;
  }

  // Else Inst is a control-path instruction, all its operand are live-outed.
  // A live-outed data-path expression and its children should never be
  // eliminated.
  typedef Instruction::op_iterator op_iterator;
  for (op_iterator I = Inst.op_begin(), E = Inst.op_end(); I != E; ++I) {
    if (VASTValPtr V = Builder.lookupExpr(*I))
      LiveOutedVal.insert(V.get());
  }

  if (LoadInst *LI = dyn_cast<LoadInst>(&Inst))
    visitLoadInst(*LI);
  else if (StoreInst *SI = dyn_cast<StoreInst>(&Inst))
    visitStoreInst(*SI);
  else if (isa<CallInst>(Inst)
           || Inst.getOpcode() == Instruction::SDiv
           || Inst.getOpcode() == Instruction::UDiv
           || Inst.getOpcode() == Instruction::SRem
           || Inst.getOpcode() == Instruction::URem)
    ++NumCalls;
  else // Unknown trivial instructions.
    return;

  // These control-path operations must be scheduled to its own step.
  ++StepLB;
}

void DesignMetricsImpl::visit(BasicBlock &BB) {
  typedef BasicBlock::iterator iterator;
  for (iterator I = BB.begin(), E = BB.end(); I != E; ++I) {
    // PHINodes will be handled in somewhere else.
    if (isa<PHINode>(I)) continue;

    visit(*I);
  }

  // Remember the incoming value from the current BB of the PHINodes in
  // successors as live-outed values.
  for (succ_iterator SI = succ_begin(&BB), SE = succ_end(&BB); SI != SE; ++SI) {
    BasicBlock *SuccBB = *SI;
    for (iterator I = SuccBB->begin(), E = SuccBB->end(); I != E; ++I) {
      PHINode *PN = dyn_cast<PHINode>(I);
      if (PN == 0) break;

      Value *LiveOutedFromBB = PN->DoPHITranslation(SuccBB, &BB);
      if (VASTValPtr V = Builder.lookupExpr(LiveOutedFromBB))
        LiveOutedVal.insert(V.get());
    }
  }

}

void DesignMetricsImpl::visit(Function &F) {
  ReversePostOrderTraversal<BasicBlock*> RPO(&F.getEntryBlock());
  typedef ReversePostOrderTraversal<BasicBlock*>::rpo_iterator iterator;
  for (iterator I = RPO.begin(), E = RPO.end(); I != E; ++I)
    visit(**I);
}

uint64_t DesignMetricsImpl::getFUCost(VASTValue *V) const {
  VASTExpr *Expr = dyn_cast<VASTExpr>(V);
  // We can only estimate the cost of VASTExpr.
  if (!Expr) return 0;

  unsigned ValueSize = std::min(V->getBitWidth(), 64u);

  switch (Expr->getOpcode()) {
  default: break;

  case VASTExpr::dpAdd: return getFUDesc<VFUAddSub>()->lookupCost(ValueSize);
  case VASTExpr::dpMul: return getFUDesc<VFUMult>()->lookupCost(ValueSize);
  case VASTExpr::dpSGT:
  case VASTExpr::dpSGE:
  case VASTExpr::dpUGT:
  case VASTExpr::dpUGE: return getFUDesc<VFUICmp>()->lookupCost(ValueSize);
  case VASTExpr::dpSel: return getFUDesc<VFUSel>()->lookupCost(ValueSize);
  case VASTExpr::dpShl:
  case VASTExpr::dpSRA:
  case VASTExpr::dpSRL: return getFUDesc<VFUShift>()->lookupCost(ValueSize);
  case VASTExpr::dpRAnd: return getFUDesc<VFUReduction>()->lookupCost(ValueSize);
  }

  return 0;
}

uint64_t DesignMetricsImpl::getExprTreeFUCost(VASTValPtr Root, ValSetTy &Visited)
                                          const {
  uint64_t Cost = 0;
  // FIXME: Provide a generic depth-first search iterator for VASTValue tree.
  typedef VASTValue::dp_dep_it ChildIt;
  std::vector<std::pair<VASTValue*, ChildIt> > WorkStack;

  WorkStack.push_back(std::make_pair(Root.get(),
                                     VASTValue::dp_dep_begin(Root.get())));

  Cost += getFUCost(Root.get());
  
  while (!WorkStack.empty()) {
    VASTValue *N;
    ChildIt It;
    tie(N, It) = WorkStack.back();

    // All children are visited.  
    if (It == VASTValue::dp_dep_end(N)) {
      WorkStack.pop_back();
      continue;
    }

    // Depth first traverse the child of current node.
    VASTValue *ChildNode = It->get().get();
    ++WorkStack.back().second;

    // Had we visited this node?
    if (!Visited.insert(ChildNode).second) continue;

    // Visit the node and compute its FU cost.
    Cost += getFUCost(ChildNode);

    WorkStack.push_back(std::make_pair(ChildNode,
                                       VASTValue::dp_dep_begin(ChildNode)));
  }

  return Cost;
}

uint64_t DesignMetricsImpl::getDatapathFUCost() const {
  uint64_t Cost = 0;
  ValSetTy Visited;

  typedef ValSetTy::const_iterator iterator;
  for (iterator I = LiveOutedVal.begin(), E = LiveOutedVal.end(); I != E; ++I)
    Cost += getExprTreeFUCost(*I, Visited);

  return Cost;
}

DesignMetrics::DesignMetrics(TargetData *TD)
  : Impl(new DesignMetricsImpl(TD)) {}

TargetData *DesignMetrics::getTargetData() const {
  return Impl->getTargetData();
}

DesignMetrics::~DesignMetrics() { delete Impl; }

void DesignMetrics::visit(Instruction &Inst) {
  Impl->visit(Inst);
}

void DesignMetrics::visit(BasicBlock &BB) {
  Impl->visit(BB);
}

void DesignMetrics::visit(Function &F) {
  Impl->visit(F);
}

unsigned DesignMetrics::getNumCalls() const { return Impl->getNumCalls(); }

DesignMetrics::DesignCost::DesignCost(uint64_t DatapathCost,
                                      unsigned NumAddrBusFanin,
                                      unsigned NumDataBusFanin,
                                      unsigned StepLB)
  : DatapathCost(DatapathCost),
    NumAddrBusFanin(NumAddrBusFanin), NumDataBusFanin(NumDataBusFanin),
    StepLB(StepLB) {}

DesignMetrics::DesignCost DesignMetrics::getCost() const {
  return DesignCost(std::max<uint64_t>(Impl->getDatapathFUCost(), 1),
                    Impl->getNumAddrBusFanin(),
                    Impl->getNumDataBusFanin(),
                    Impl->getStepsLowerBound());
}

void DesignMetrics::reset() { Impl->reset(); }

uint64_t DesignMetrics::DesignCost::getCostInc(unsigned Multiply, uint64_t Alpha,
                                               uint64_t Beta, uint64_t Gama) const {
  VFUMux *MUX = getFUDesc<VFUMux>();
  VFUMemBus *MemBus = getFUDesc<VFUMemBus>();
  unsigned AddrWidth = MemBus->getAddrWidth();
  unsigned DataWidth = MemBus->getDataWidth();

  return Alpha * (uint64_t(Multiply) - 1) * DatapathCost
         + Beta * (MUX->getMuxCost(Multiply * NumAddrBusFanin, AddrWidth)
                   - MUX->getMuxCost(NumAddrBusFanin, AddrWidth))
         + Beta * (MUX->getMuxCost(Multiply * NumDataBusFanin, DataWidth)
                   - MUX->getMuxCost(NumDataBusFanin, DataWidth))
         + Gama * (uint64_t(Multiply) - 1) * StepLB;
}

void DesignMetrics::DesignCost::print(raw_ostream &OS) const {
  OS << "{ Data-path: " << DatapathCost
     << ", ( AddrBusFI: " << NumAddrBusFanin
     << ", DataBusFI: " << NumDataBusFanin
     << " ), StepLB: " << StepLB << " }";
}

void DesignMetrics::DesignCost::dump() const {
  print(dbgs());
  dbgs() << '\n';
}

char DesignMetricsPass::ID = 0;

bool DesignMetricsPass::runOnFunction(Function &F) {
  DesignMetrics Metrics(&getAnalysis<TargetData>());

  Metrics.visit(F);

  //DEBUG(dbgs() << "Data-path cost of function " << F.getName() << ':'
  //             << Metrics.getResourceCost() << '\n');
  
  return false;
}

FunctionPass *llvm::createDesignMetricsPass() {
  return new DesignMetricsPass();
}
